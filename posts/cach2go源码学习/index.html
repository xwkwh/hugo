<!DOCTYPE html>
<html lang="en">

  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="Content-Language" content="en">

    <meta name="author" content="Toby">
    <meta name="description" content="Cach2go源码学习 最近在磕golang，实战项目还不多，周末闲暇之余找了一个比较简单的开源库研究研究，阅读大牛写的开源代码应该对自己学习很有帮助，还能学一些设计思想。为了防止遗忘，把学到的相关记录了一下 cache2go是一个使用golang实现的并发安全并且包含超时机制的缓存库、缓存方式为表，表中可存储key-value方式的数据，可以学习到锁、goroutie、map的使用 关键的几个文件：
cache.go cachetable.go cacheitem.go errors.go Cache cache.go 返回或者创建一个cacheTable
var ( //俩个全局变量  //cache 实际的存储cache，key是string，value是*CacheTable  //mutex 是一个RWMutex，读写锁 	cache = make(map[string]*CacheTable) mutex sync.RWMutex ) // Cache returns the existing cache table with given name or creates a new one // if the table does not exist yet. func Cache(table string) *CacheTable { mutex.RLock() //当外部调用的时候，先判断有无table，该操作不涉及写，所以用Rlock 	t, ok := cache[table] mutex.RUnlock() //存在直接返回table，不存在  //则进行相应的操作，新建一个table，该操作为了同步，加Lock 	if !ok { mutex.">
    <meta name="keywords" content="blog,developer,personal">

    <meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Cach2go源码学习"/>
<meta name="twitter:description" content="Cach2go源码学习 最近在磕golang，实战项目还不多，周末闲暇之余找了一个比较简单的开源库研究研究，阅读大牛写的开源代码应该对自己学习很有帮助，还能学一些设计思想。为了防止遗忘，把学到的相关记录了一下 cache2go是一个使用golang实现的并发安全并且包含超时机制的缓存库、缓存方式为表，表中可存储key-value方式的数据，可以学习到锁、goroutie、map的使用 关键的几个文件：
cache.go cachetable.go cacheitem.go errors.go Cache cache.go 返回或者创建一个cacheTable
var ( //俩个全局变量  //cache 实际的存储cache，key是string，value是*CacheTable  //mutex 是一个RWMutex，读写锁 	cache = make(map[string]*CacheTable) mutex sync.RWMutex ) // Cache returns the existing cache table with given name or creates a new one // if the table does not exist yet. func Cache(table string) *CacheTable { mutex.RLock() //当外部调用的时候，先判断有无table，该操作不涉及写，所以用Rlock 	t, ok := cache[table] mutex.RUnlock() //存在直接返回table，不存在  //则进行相应的操作，新建一个table，该操作为了同步，加Lock 	if !ok { mutex."/>

    <meta property="og:title" content="Cach2go源码学习" />
<meta property="og:description" content="Cach2go源码学习 最近在磕golang，实战项目还不多，周末闲暇之余找了一个比较简单的开源库研究研究，阅读大牛写的开源代码应该对自己学习很有帮助，还能学一些设计思想。为了防止遗忘，把学到的相关记录了一下 cache2go是一个使用golang实现的并发安全并且包含超时机制的缓存库、缓存方式为表，表中可存储key-value方式的数据，可以学习到锁、goroutie、map的使用 关键的几个文件：
cache.go cachetable.go cacheitem.go errors.go Cache cache.go 返回或者创建一个cacheTable
var ( //俩个全局变量  //cache 实际的存储cache，key是string，value是*CacheTable  //mutex 是一个RWMutex，读写锁 	cache = make(map[string]*CacheTable) mutex sync.RWMutex ) // Cache returns the existing cache table with given name or creates a new one // if the table does not exist yet. func Cache(table string) *CacheTable { mutex.RLock() //当外部调用的时候，先判断有无table，该操作不涉及写，所以用Rlock 	t, ok := cache[table] mutex.RUnlock() //存在直接返回table，不存在  //则进行相应的操作，新建一个table，该操作为了同步，加Lock 	if !ok { mutex." />
<meta property="og:type" content="article" />
<meta property="og:url" content="http://xwkwh.github.io/hugo/posts/cach2go%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/" />
<meta property="article:published_time" content="2018-06-24T16:10:26+00:00" />
<meta property="article:modified_time" content="2018-06-24T16:10:26+00:00" />


    <title>
  Cach2go源码学习 · Toby
</title>

    
      <link rel="canonical" href="http://xwkwh.github.io/hugo/posts/cach2go%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/">
    

    <link href="https://fonts.googleapis.com/css?family=Lato:400,700%7CMerriweather:300,700%7CSource+Code+Pro:400,700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/fork-awesome@1.1.7/css/fork-awesome.min.css" integrity="sha256-gsmEoJAws/Kd3CjuOQzLie5Q3yshhvmo7YNtBG7aaEY=" crossorigin="anonymous">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.1/normalize.min.css" integrity="sha256-l85OmPOjvil/SOvVt3HnSSjzF1TUMyT9eV0c2BzEGzU=" crossorigin="anonymous" />

    
      
      
      <link rel="stylesheet" href="/hugo/css/coder.min.f01c647a0d25b40da992a37c3376291185eed8a50ced8c26cc2c0bcfe38c97df.css" integrity="sha256-8Bxkeg0ltA2pkqN8M3YpEYXu2KUM7YwmzCwLz&#43;OMl98=" crossorigin="anonymous" media="screen" />
    

    

    
      
        
        
        <link rel="stylesheet" href="/hugo/css/coder-dark.min.126ad3988d46bdae6217a11105b53c9662bca05f39d42d3c0fb366919d334620.css" integrity="sha256-EmrTmI1Gva5iF6ERBbU8lmK8oF851C08D7NmkZ0zRiA=" crossorigin="anonymous" media="screen" />
      
    

    

    

    <link rel="icon" type="image/png" href="/hugo/img/favicon-32x32.png" sizes="32x32">
    <link rel="icon" type="image/png" href="/hugo/img/favicon-16x16.png" sizes="16x16">

    <link rel="apple-touch-icon" href="/hugo/images/apple-touch-icon.png">
    <link rel="apple-touch-icon" sizes="180x180" href="/hugo/images/apple-touch-icon.png">

    
      <script src="https://twemoji.maxcdn.com/v/latest/twemoji.min.js" crossorigin="anonymous"></script>
    

    <meta name="generator" content="Hugo 0.79.0-DEV" />
  </head>

  
  
    
  
  <body class="colorscheme-dark"
        onload=" twemoji.parse(document.body); "
  >
    
<div class="float-container">
    <a id="dark-mode-toggle" class="colorscheme-toggle">
        <i class="fa fa-adjust fa-fw" aria-hidden="true"></i>
    </a>
</div>


    <main class="wrapper">
      <nav class="navigation">
  <section class="container">
    <a class="navigation-title" href="/hugo">
      Toby
    </a>
    
      <input type="checkbox" id="menu-toggle" />
      <label class="menu-button float-right" for="menu-toggle">
        <i class="fa fa-bars fa-fw" aria-hidden="true"></i>
      </label>
      <ul class="navigation-list">
        
          
            <li class="navigation-item">
              <a class="navigation-link" href="/hugo/posts/">Blog</a>
            </li>
          
            <li class="navigation-item">
              <a class="navigation-link" href="/hugo/contact/">Contact me</a>
            </li>
          
            <li class="navigation-item">
              <a class="navigation-link" href="/hugo/about/">About</a>
            </li>
          
            <li class="navigation-item">
              <a class="navigation-link" href="/hugo/projects">Projects</a>
            </li>
          
        
        
      </ul>
    
  </section>
</nav>


      <div class="content">
        
  <section class="container post">
    <article>
      <header>
        <div class="post-title">
          <h1 class="title">Cach2go源码学习</h1>
        </div>
        <div class="post-meta">
          <div class="date">
            <span class="posted-on">
              <i class="fa fa-calendar" aria-hidden="true"></i>
              <time datetime='2018-06-24T16:10:26Z'>
                June 24, 2018
              </time>
            </span>
            <span class="reading-time">
              <i class="fa fa-clock-o" aria-hidden="true"></i>
              9-minute read
            </span>
          </div>
          
          
          <div class="tags">
  <i class="fa fa-tag" aria-hidden="true"></i>
    <a href="/hugo/tags/golang/">Golang</a></div>

        </div>
      </header>

      <div>
        
        <h2 id="cach2go源码学习">Cach2go源码学习</h2>
<p>最近在磕golang，实战项目还不多，周末闲暇之余找了一个比较简单的开源库研究研究，阅读大牛写的开源代码应该对自己学习很有帮助，还能学一些设计思想。为了防止遗忘，把学到的相关记录了一下
cache2go是一个使用golang实现的并发安全并且包含超时机制的缓存库、缓存方式为表，表中可存储key-value方式的数据，可以学习到锁、goroutie、map的使用
关键的几个文件：</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fallback" data-lang="fallback">cache.go
cachetable.go
cacheitem.go
errors.go
</code></pre></div><h4 id="cache">Cache</h4>
<p>cache.go 返回或者创建一个cacheTable</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#fff;font-weight:bold">var</span> (
    <span style="color:#007f7f">//俩个全局变量
</span><span style="color:#007f7f"></span>    <span style="color:#007f7f">//cache 实际的存储cache，key是string，value是*CacheTable
</span><span style="color:#007f7f"></span>    <span style="color:#007f7f">//mutex 是一个RWMutex，读写锁
</span><span style="color:#007f7f"></span>	cache = <span style="color:#fff;font-weight:bold">make</span>(<span style="color:#fff;font-weight:bold">map</span>[<span style="color:#fff;font-weight:bold">string</span>]*CacheTable)
	mutex sync.RWMutex
)
<span style="color:#007f7f">// Cache returns the existing cache table with given name or creates a new one
</span><span style="color:#007f7f">// if the table does not exist yet.
</span><span style="color:#007f7f"></span><span style="color:#fff;font-weight:bold">func</span> Cache(table <span style="color:#fff;font-weight:bold">string</span>) *CacheTable {
	mutex.RLock()  <span style="color:#007f7f">//当外部调用的时候，先判断有无table，该操作不涉及写，所以用Rlock
</span><span style="color:#007f7f"></span>	t, ok := cache[table]
	mutex.RUnlock()
	<span style="color:#007f7f">//存在直接返回table，不存在
</span><span style="color:#007f7f"></span>    <span style="color:#007f7f">//则进行相应的操作，新建一个table，该操作为了同步，加Lock
</span><span style="color:#007f7f"></span>	<span style="color:#fff;font-weight:bold">if</span> !ok {
		mutex.Lock()
		t, ok = cache[table]
		<span style="color:#007f7f">// Double check whether the table exists or not.
</span><span style="color:#007f7f"></span>		<span style="color:#fff;font-weight:bold">if</span> !ok {
			t = &amp;CacheTable{
				name:  table,
				items: <span style="color:#fff;font-weight:bold">make</span>(<span style="color:#fff;font-weight:bold">map</span>[<span style="color:#fff;font-weight:bold">interface</span>{}]*CacheItem),
			}
			cache[table] = t
		}
		mutex.Unlock()
	}

	<span style="color:#fff;font-weight:bold">return</span> t
}
</code></pre></div><h4 id="cachetable">CacheTable</h4>
<p>接下来看看cacheTable.go，包含了相关的表结构体和表操作。CacheTable结构体中我们可以看出缓存项为一个map items，并存在指定得表名中(name)中，cleanupTimer与cleanupInterval控制清理缓存。以及三个回调函数。并提供了增加、删除、查找、遍历、刷新等操作。<br>
其中比较特殊的就是缓存清理周期。主要代码在expirationCheck函数中实现。代码会遍历所有缓存项，为了保证计时器的准确性每次循环都会更新，生命周期设置为‘0’代表永久有效，找到过期的项删除，然后找到即将要过期项的时间用作cleanupInterval(缓存周期)，即下一次缓存更新的时间，开一个gotoutine在缓存周期到了后清理。</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#007f7f">// CacheTable is a table within the cache
</span><span style="color:#007f7f"></span><span style="color:#fff;font-weight:bold">type</span> CacheTable <span style="color:#fff;font-weight:bold">struct</span> {
	sync.RWMutex
    
	<span style="color:#007f7f">// The table&#39;s name. 缓存表名
</span><span style="color:#007f7f"></span>	name <span style="color:#fff;font-weight:bold">string</span>
	<span style="color:#007f7f">// All cached items. 缓存项，CacheItem结构体为缓存的具体项
</span><span style="color:#007f7f"></span>	items <span style="color:#fff;font-weight:bold">map</span>[<span style="color:#fff;font-weight:bold">interface</span>{}]*CacheItem

	<span style="color:#007f7f">// Timer responsible for triggering cleanup.  
</span><span style="color:#007f7f"></span>    <span style="color:#007f7f">// 触发缓存清理的定时器
</span><span style="color:#007f7f"></span>	cleanupTimer *time.Timer
	<span style="color:#007f7f">// Current timer duration.
</span><span style="color:#007f7f"></span>    <span style="color:#007f7f">// 缓存清理周期
</span><span style="color:#007f7f"></span>	cleanupInterval time.Duration

	<span style="color:#007f7f">// The logger used for this table.  缓存表的日志
</span><span style="color:#007f7f"></span>	logger *log.Logger

	<span style="color:#007f7f">// Callback method triggered when trying to load a non-existing key.
</span><span style="color:#007f7f"></span>    <span style="color:#007f7f">// 获取一个不存在的缓存项时的回调函数
</span><span style="color:#007f7f"></span>	loadData <span style="color:#fff;font-weight:bold">func</span>(key <span style="color:#fff;font-weight:bold">interface</span>{}, args ...<span style="color:#fff;font-weight:bold">interface</span>{}) *CacheItem
	<span style="color:#007f7f">// Callback method triggered when adding a new item to the cache.
</span><span style="color:#007f7f"></span>    <span style="color:#007f7f">// 向缓存表增加缓存项时的回调函数
</span><span style="color:#007f7f"></span>	addedItem <span style="color:#fff;font-weight:bold">func</span>(item *CacheItem)
	<span style="color:#007f7f">// Callback method triggered before deleting an item from the cache.
</span><span style="color:#007f7f"></span>    <span style="color:#007f7f">// 从缓存表删除一个缓存项时的回调函数
</span><span style="color:#007f7f"></span>	aboutToDeleteItem <span style="color:#fff;font-weight:bold">func</span>(item *CacheItem)
}
<span style="color:#007f7f">// Count returns how many items are currently stored in the cache.
</span><span style="color:#007f7f">// 缓存表中缓存数量
</span><span style="color:#007f7f"></span><span style="color:#fff;font-weight:bold">func</span> (table *CacheTable) Count() <span style="color:#fff;font-weight:bold">int</span> {
	table.RLock()   <span style="color:#007f7f">//只需要读，加RLock
</span><span style="color:#007f7f"></span>	<span style="color:#fff;font-weight:bold">defer</span> table.RUnlock()
	<span style="color:#fff;font-weight:bold">return</span> <span style="color:#fff;font-weight:bold">len</span>(table.items)  <span style="color:#007f7f">//数量即items的长度
</span><span style="color:#007f7f"></span>}

<span style="color:#007f7f">// Foreach all items 遍历所有缓存项
</span><span style="color:#007f7f"></span><span style="color:#fff;font-weight:bold">func</span> (table *CacheTable) Foreach(trans <span style="color:#fff;font-weight:bold">func</span>(key <span style="color:#fff;font-weight:bold">interface</span>{}, item *CacheItem)) {
	table.RLock()    <span style="color:#007f7f">// 加读锁
</span><span style="color:#007f7f"></span>	<span style="color:#fff;font-weight:bold">defer</span> table.RUnlock()

	<span style="color:#fff;font-weight:bold">for</span> k, v := <span style="color:#fff;font-weight:bold">range</span> table.items {
		trans(k, v) <span style="color:#007f7f">//遍历相关的操作
</span><span style="color:#007f7f"></span>	}
}

<span style="color:#007f7f">// SetDataLoader configures a data-loader callback, which will be called when
</span><span style="color:#007f7f">// trying to access a non-existing key. The key and 0...n additional arguments
</span><span style="color:#007f7f">// are passed to the callback function.
</span><span style="color:#007f7f">// SetDataLoader配置一个数据加载的回调，当尝试去请求一个不存在的key的时候调用
</span><span style="color:#007f7f"></span><span style="color:#fff;font-weight:bold">func</span> (table *CacheTable) SetDataLoader(f <span style="color:#fff;font-weight:bold">func</span>(<span style="color:#fff;font-weight:bold">interface</span>{}, ...<span style="color:#fff;font-weight:bold">interface</span>{}) *CacheItem) {
	table.Lock()
	<span style="color:#fff;font-weight:bold">defer</span> table.Unlock()
	table.loadData = f
}

<span style="color:#007f7f">// SetAddedItemCallback configures a callback, which will be called every time
</span><span style="color:#007f7f">// a new item is added to the cache.
</span><span style="color:#007f7f">// SetAddedItemCallback配置一个回调，当向缓存中添加项目时每次都会被调用
</span><span style="color:#007f7f"></span><span style="color:#fff;font-weight:bold">func</span> (table *CacheTable) SetAddedItemCallback(f <span style="color:#fff;font-weight:bold">func</span>(*CacheItem)) {
	table.Lock()
	<span style="color:#fff;font-weight:bold">defer</span> table.Unlock()
	table.addedItem = f
}

<span style="color:#007f7f">// SetAboutToDeleteItemCallback configures a callback, which will be called
</span><span style="color:#007f7f">// every time an item is about to be removed from the cache.
</span><span style="color:#007f7f">// setabouttodeleteitemcallback配置一个回调，当一个项目从缓存中删除时每次都会被调用
</span><span style="color:#007f7f"></span><span style="color:#fff;font-weight:bold">func</span> (table *CacheTable) SetAboutToDeleteItemCallback(f <span style="color:#fff;font-weight:bold">func</span>(*CacheItem)) {
	table.Lock()
	<span style="color:#fff;font-weight:bold">defer</span> table.Unlock()
	table.aboutToDeleteItem = f
}

<span style="color:#007f7f">// SetLogger sets the logger to be used by this cache table.
</span><span style="color:#007f7f">// 设置缓存表需要使用的log
</span><span style="color:#007f7f"></span><span style="color:#fff;font-weight:bold">func</span> (table *CacheTable) SetLogger(logger *log.Logger) {
	table.Lock()
	<span style="color:#fff;font-weight:bold">defer</span> table.Unlock()
	table.logger = logger
}

<span style="color:#007f7f">// Expiration check loop, triggered by a self-adjusting timer.
</span><span style="color:#007f7f">// 终结检查，被自调整的时间触发
</span><span style="color:#007f7f"></span><span style="color:#fff;font-weight:bold">func</span> (table *CacheTable) expirationCheck() {
	table.Lock()
	<span style="color:#fff;font-weight:bold">if</span> table.cleanupTimer != <span style="color:#fff;font-weight:bold">nil</span> {
		table.cleanupTimer.Stop()
	}
	<span style="color:#fff;font-weight:bold">if</span> table.cleanupInterval &gt; <span style="color:#ff0;font-weight:bold">0</span> {
		table.log(<span style="color:#0ff;font-weight:bold">&#34;Expiration check triggered after&#34;</span>, table.cleanupInterval, <span style="color:#0ff;font-weight:bold">&#34;for table&#34;</span>, table.name)
	} <span style="color:#fff;font-weight:bold">else</span> {
		table.log(<span style="color:#0ff;font-weight:bold">&#34;Expiration check installed for table&#34;</span>, table.name)
	}

	<span style="color:#007f7f">// To be more accurate with timers, we would need to update &#39;now&#39; on every
</span><span style="color:#007f7f"></span>	<span style="color:#007f7f">// loop iteration. Not sure it&#39;s really efficient though.
</span><span style="color:#007f7f"></span>    <span style="color:#007f7f">// 为了定时器更准确，我们需要在每一个循环中更新‘now’，不确定是否是有效率的。
</span><span style="color:#007f7f"></span>	now := time.Now()
	smallestDuration := <span style="color:#ff0;font-weight:bold">0</span> * time.Second  
    <span style="color:#007f7f">// 设置默认最小值，遍历items找到其中最接近超时的时间设置为下一次的缓存间隔
</span><span style="color:#007f7f"></span>	<span style="color:#fff;font-weight:bold">for</span> key, item := <span style="color:#fff;font-weight:bold">range</span> table.items {
		<span style="color:#007f7f">// Cache values so we don&#39;t keep blocking the mutex.
</span><span style="color:#007f7f"></span>		item.RLock()
		lifeSpan := item.lifeSpan
		accessedOn := item.accessedOn
		item.RUnlock()

		<span style="color:#fff;font-weight:bold">if</span> lifeSpan == <span style="color:#ff0;font-weight:bold">0</span> {  <span style="color:#007f7f">//可以看出，lifespan为0可以永久有效
</span><span style="color:#007f7f"></span>			<span style="color:#fff;font-weight:bold">continue</span>
		}
		<span style="color:#fff;font-weight:bold">if</span> now.Sub(accessedOn) &gt;= lifeSpan { 
			<span style="color:#007f7f">// Item has excessed its lifespan.
</span><span style="color:#007f7f"></span>			table.deleteInternal(key) <span style="color:#007f7f">//到期的删除
</span><span style="color:#007f7f"></span>		} <span style="color:#fff;font-weight:bold">else</span> {
			<span style="color:#007f7f">// Find the item chronologically closest to its end-of-lifespan.
</span><span style="color:#007f7f"></span>			<span style="color:#fff;font-weight:bold">if</span> smallestDuration == <span style="color:#ff0;font-weight:bold">0</span> || lifeSpan-now.Sub(accessedOn) &lt; smallestDuration {
				smallestDuration = lifeSpan - now.Sub(accessedOn)
			}<span style="color:#007f7f">//更新smallestDuration使其为items中最小的即将过期的时间，这样方便及时清理
</span><span style="color:#007f7f"></span>		}
	}

	<span style="color:#007f7f">// Setup the interval for the next cleanup run.
</span><span style="color:#007f7f"></span>    <span style="color:#007f7f">// 把最小时间赋值给cleanupInterval
</span><span style="color:#007f7f"></span>	table.cleanupInterval = smallestDuration
	<span style="color:#fff;font-weight:bold">if</span> smallestDuration &gt; <span style="color:#ff0;font-weight:bold">0</span> {
		table.cleanupTimer = time.AfterFunc(smallestDuration, <span style="color:#fff;font-weight:bold">func</span>() {
			<span style="color:#fff;font-weight:bold">go</span> table.expirationCheck() <span style="color:#007f7f">//通过定时器去并行触发自检
</span><span style="color:#007f7f"></span>		})
	}
	table.Unlock()
}

<span style="color:#fff;font-weight:bold">func</span> (table *CacheTable) addInternal(item *CacheItem) {
	<span style="color:#007f7f">// Careful: do not run this method unless the table-mutex is locked!
</span><span style="color:#007f7f"></span>	<span style="color:#007f7f">// It will unlock it for the caller before running the callbacks and checks
</span><span style="color:#007f7f"></span>	table.log(<span style="color:#0ff;font-weight:bold">&#34;Adding item with key&#34;</span>, item.key, <span style="color:#0ff;font-weight:bold">&#34;and lifespan of&#34;</span>, item.lifeSpan, <span style="color:#0ff;font-weight:bold">&#34;to table&#34;</span>, table.name)
	table.items[item.key] = item

	<span style="color:#007f7f">// Cache values so we don&#39;t keep blocking the mutex.
</span><span style="color:#007f7f"></span>	expDur := table.cleanupInterval
	addedItem := table.addedItem
	table.Unlock()

	<span style="color:#007f7f">// Trigger callback after adding an item to cache.
</span><span style="color:#007f7f"></span>	<span style="color:#fff;font-weight:bold">if</span> addedItem != <span style="color:#fff;font-weight:bold">nil</span> {
		addedItem(item)
	}

	<span style="color:#007f7f">// If we haven&#39;t set up any expiration check timer or found a more imminent item.
</span><span style="color:#007f7f"></span>	<span style="color:#fff;font-weight:bold">if</span> item.lifeSpan &gt; <span style="color:#ff0;font-weight:bold">0</span> &amp;&amp; (expDur == <span style="color:#ff0;font-weight:bold">0</span> || item.lifeSpan &lt; expDur) {
		table.expirationCheck()
	}
}

<span style="color:#007f7f">// Add adds a key/value pair to the cache.
</span><span style="color:#007f7f">// Parameter key is the item&#39;s cache-key.
</span><span style="color:#007f7f">// Parameter lifeSpan determines after which time period without an access the item
</span><span style="color:#007f7f">// will get removed from the cache.
</span><span style="color:#007f7f">// Parameter data is the item&#39;s value.
</span><span style="color:#007f7f">// 添加键值对到缓存中
</span><span style="color:#007f7f">// 参数key是cache-key。
</span><span style="color:#007f7f">// 参数lifeSpan(生命周期)，确定在没有访问该项目的时间段后将从缓存中移除
</span><span style="color:#007f7f">// 参数data是项目中的值
</span><span style="color:#007f7f"></span><span style="color:#fff;font-weight:bold">func</span> (table *CacheTable) Add(key <span style="color:#fff;font-weight:bold">interface</span>{}, lifeSpan time.Duration, data <span style="color:#fff;font-weight:bold">interface</span>{}) *CacheItem {
	item := NewCacheItem(key, lifeSpan, data) <span style="color:#007f7f">// 构造一个item
</span><span style="color:#007f7f"></span>
	<span style="color:#007f7f">// Add item to cache.
</span><span style="color:#007f7f"></span>	table.Lock()
	table.addInternal(item) <span style="color:#007f7f">// 添加进去，在这个函数中解锁
</span><span style="color:#007f7f"></span>
	<span style="color:#fff;font-weight:bold">return</span> item
}

<span style="color:#fff;font-weight:bold">func</span> (table *CacheTable) deleteInternal(key <span style="color:#fff;font-weight:bold">interface</span>{}) (*CacheItem, <span style="color:#fff;font-weight:bold">error</span>) {
	r, ok := table.items[key]
	<span style="color:#fff;font-weight:bold">if</span> !ok {
		<span style="color:#fff;font-weight:bold">return</span> <span style="color:#fff;font-weight:bold">nil</span>, ErrKeyNotFound
	}

	<span style="color:#007f7f">// Cache value so we don&#39;t keep blocking the mutex.
</span><span style="color:#007f7f"></span>	aboutToDeleteItem := table.aboutToDeleteItem
	table.Unlock()

	<span style="color:#007f7f">// Trigger callbacks before deleting an item from cache.
</span><span style="color:#007f7f"></span>	<span style="color:#fff;font-weight:bold">if</span> aboutToDeleteItem != <span style="color:#fff;font-weight:bold">nil</span> {
		aboutToDeleteItem(r)
	}

	r.RLock()
	<span style="color:#fff;font-weight:bold">defer</span> r.RUnlock()
	<span style="color:#fff;font-weight:bold">if</span> r.aboutToExpire != <span style="color:#fff;font-weight:bold">nil</span> {
		r.aboutToExpire(key)
	}

	table.Lock()
	table.log(<span style="color:#0ff;font-weight:bold">&#34;Deleting item with key&#34;</span>, key, <span style="color:#0ff;font-weight:bold">&#34;created on&#34;</span>, r.createdOn, <span style="color:#0ff;font-weight:bold">&#34;and hit&#34;</span>, r.accessCount, <span style="color:#0ff;font-weight:bold">&#34;times from table&#34;</span>, table.name)
	<span style="color:#fff;font-weight:bold">delete</span>(table.items, key)  <span style="color:#007f7f">//golang自带 map delete函数
</span><span style="color:#007f7f"></span>
	<span style="color:#fff;font-weight:bold">return</span> r, <span style="color:#fff;font-weight:bold">nil</span>
}

<span style="color:#007f7f">// Delete an item from the cache.
</span><span style="color:#007f7f"></span><span style="color:#fff;font-weight:bold">func</span> (table *CacheTable) Delete(key <span style="color:#fff;font-weight:bold">interface</span>{}) (*CacheItem, <span style="color:#fff;font-weight:bold">error</span>) {
	table.Lock()
	<span style="color:#fff;font-weight:bold">defer</span> table.Unlock()
    <span style="color:#007f7f">//作者封装重构了下
</span><span style="color:#007f7f"></span>	<span style="color:#fff;font-weight:bold">return</span> table.deleteInternal(key)
}

<span style="color:#007f7f">// Exists returns whether an item exists in the cache. Unlike the Value method
</span><span style="color:#007f7f">// Exists neither tries to fetch data via the loadData callback nor does it
</span><span style="color:#007f7f">// keep the item alive in the cache.
</span><span style="color:#007f7f"></span><span style="color:#fff;font-weight:bold">func</span> (table *CacheTable) Exists(key <span style="color:#fff;font-weight:bold">interface</span>{}) <span style="color:#fff;font-weight:bold">bool</span> {
	table.RLock()
	<span style="color:#fff;font-weight:bold">defer</span> table.RUnlock()
	_, ok := table.items[key] <span style="color:#007f7f">//判断key存不存在
</span><span style="color:#007f7f"></span>	<span style="color:#fff;font-weight:bold">return</span> ok
}

<span style="color:#007f7f">// NotFoundAdd tests whether an item not found in the cache. Unlike the Exists
</span><span style="color:#007f7f">// method this also adds data if they key could not be found.
</span><span style="color:#007f7f"></span><span style="color:#fff;font-weight:bold">func</span> (table *CacheTable) NotFoundAdd(key <span style="color:#fff;font-weight:bold">interface</span>{}, lifeSpan time.Duration, data <span style="color:#fff;font-weight:bold">interface</span>{}) <span style="color:#fff;font-weight:bold">bool</span> {
	table.Lock()

	<span style="color:#fff;font-weight:bold">if</span> _, ok := table.items[key]; ok {
		table.Unlock()
		<span style="color:#fff;font-weight:bold">return</span> <span style="color:#fff;font-weight:bold">false</span>
	}

	item := NewCacheItem(key, lifeSpan, data)
	table.addInternal(item)

	<span style="color:#fff;font-weight:bold">return</span> <span style="color:#fff;font-weight:bold">true</span>
}

<span style="color:#007f7f">// Value returns an item from the cache and marks it to be kept alive. You can
</span><span style="color:#007f7f">// pass additional arguments to your DataLoader callback function.
</span><span style="color:#007f7f"></span><span style="color:#fff;font-weight:bold">func</span> (table *CacheTable) Value(key <span style="color:#fff;font-weight:bold">interface</span>{}, args ...<span style="color:#fff;font-weight:bold">interface</span>{}) (*CacheItem, <span style="color:#fff;font-weight:bold">error</span>) {
	table.RLock()
	r, ok := table.items[key]
	loadData := table.loadData
	table.RUnlock()

	<span style="color:#fff;font-weight:bold">if</span> ok {
		<span style="color:#007f7f">// Update access counter and timestamp.
</span><span style="color:#007f7f"></span>		r.KeepAlive()
		<span style="color:#fff;font-weight:bold">return</span> r, <span style="color:#fff;font-weight:bold">nil</span>
	}

	<span style="color:#007f7f">// Item doesn&#39;t exist in cache. Try and fetch it with a data-loader.
</span><span style="color:#007f7f"></span>	<span style="color:#fff;font-weight:bold">if</span> loadData != <span style="color:#fff;font-weight:bold">nil</span> {
		item := loadData(key, args...)
		<span style="color:#fff;font-weight:bold">if</span> item != <span style="color:#fff;font-weight:bold">nil</span> {
			table.Add(key, item.lifeSpan, item.data)
			<span style="color:#fff;font-weight:bold">return</span> item, <span style="color:#fff;font-weight:bold">nil</span>
		}

		<span style="color:#fff;font-weight:bold">return</span> <span style="color:#fff;font-weight:bold">nil</span>, ErrKeyNotFoundOrLoadable
	}

	<span style="color:#fff;font-weight:bold">return</span> <span style="color:#fff;font-weight:bold">nil</span>, ErrKeyNotFound
}

<span style="color:#007f7f">// Flush deletes all items from this cache table.
</span><span style="color:#007f7f"></span><span style="color:#fff;font-weight:bold">func</span> (table *CacheTable) Flush() {
	table.Lock()
	<span style="color:#fff;font-weight:bold">defer</span> table.Unlock()

	table.log(<span style="color:#0ff;font-weight:bold">&#34;Flushing table&#34;</span>, table.name)

	table.items = <span style="color:#fff;font-weight:bold">make</span>(<span style="color:#fff;font-weight:bold">map</span>[<span style="color:#fff;font-weight:bold">interface</span>{}]*CacheItem)
	table.cleanupInterval = <span style="color:#ff0;font-weight:bold">0</span>
	<span style="color:#fff;font-weight:bold">if</span> table.cleanupTimer != <span style="color:#fff;font-weight:bold">nil</span> {
		table.cleanupTimer.Stop()
	}
}

<span style="color:#007f7f">// CacheItemPair maps key to access counter
</span><span style="color:#007f7f"></span><span style="color:#fff;font-weight:bold">type</span> CacheItemPair <span style="color:#fff;font-weight:bold">struct</span> {
	Key         <span style="color:#fff;font-weight:bold">interface</span>{}
	AccessCount <span style="color:#fff;font-weight:bold">int64</span>
}

<span style="color:#007f7f">// CacheItemPairList is a slice of CacheIemPairs that implements sort.
</span><span style="color:#007f7f">// Interface to sort by AccessCount.
</span><span style="color:#007f7f"></span><span style="color:#fff;font-weight:bold">type</span> CacheItemPairList []CacheItemPair

<span style="color:#fff;font-weight:bold">func</span> (p CacheItemPairList) Swap(i, j <span style="color:#fff;font-weight:bold">int</span>)      { p[i], p[j] = p[j], p[i] }
<span style="color:#fff;font-weight:bold">func</span> (p CacheItemPairList) Len() <span style="color:#fff;font-weight:bold">int</span>           { <span style="color:#fff;font-weight:bold">return</span> <span style="color:#fff;font-weight:bold">len</span>(p) }
<span style="color:#fff;font-weight:bold">func</span> (p CacheItemPairList) Less(i, j <span style="color:#fff;font-weight:bold">int</span>) <span style="color:#fff;font-weight:bold">bool</span> { <span style="color:#fff;font-weight:bold">return</span> p[i].AccessCount &gt; p[j].AccessCount }

<span style="color:#007f7f">// MostAccessed returns the most accessed items in this cache table
</span><span style="color:#007f7f">// 返回缓存表中被访问最多的项目
</span><span style="color:#007f7f"></span><span style="color:#fff;font-weight:bold">func</span> (table *CacheTable) MostAccessed(count <span style="color:#fff;font-weight:bold">int64</span>) []*CacheItem {
	table.RLock()
	<span style="color:#fff;font-weight:bold">defer</span> table.RUnlock()

	p := <span style="color:#fff;font-weight:bold">make</span>(CacheItemPairList, <span style="color:#fff;font-weight:bold">len</span>(table.items))
	i := <span style="color:#ff0;font-weight:bold">0</span>
	<span style="color:#fff;font-weight:bold">for</span> k, v := <span style="color:#fff;font-weight:bold">range</span> table.items {
		p[i] = CacheItemPair{k, v.accessCount}
		i++
	}
	sort.Sort(p)
    
	<span style="color:#fff;font-weight:bold">var</span> r []*CacheItem
	c := <span style="color:#fff;font-weight:bold">int64</span>(<span style="color:#ff0;font-weight:bold">0</span>)
	<span style="color:#fff;font-weight:bold">for</span> _, v := <span style="color:#fff;font-weight:bold">range</span> p {
		<span style="color:#fff;font-weight:bold">if</span> c &gt;= count {
			<span style="color:#fff;font-weight:bold">break</span>
		}
		item, ok := table.items[v.Key]
		<span style="color:#fff;font-weight:bold">if</span> ok {
			r = <span style="color:#fff;font-weight:bold">append</span>(r, item)
		}
		c++
	}
	<span style="color:#fff;font-weight:bold">return</span> r
}

<span style="color:#007f7f">// Internal logging method for convenience.  为了方便封装的log方法
</span><span style="color:#007f7f"></span><span style="color:#fff;font-weight:bold">func</span> (table *CacheTable) log(v ...<span style="color:#fff;font-weight:bold">interface</span>{}) {
	<span style="color:#fff;font-weight:bold">if</span> table.logger == <span style="color:#fff;font-weight:bold">nil</span> {
		<span style="color:#fff;font-weight:bold">return</span>
	}

	table.logger.Println(v)
}

</code></pre></div><h4 id="cacheitem">CacheItem</h4>
<p>接下来看<strong>cacheItem.go</strong>文件，该文件是表中的缓存项CacheItem的实现，从结构体中我们可以看到key与data都是interface{}，即可以传任意类型，但是建议key为可比较的类型。
lifeSpan time.Duration 可设置生命周期，以及创建时间，访问次数等记录</p>
<p><strong>读锁，在不需要改写的变量上，不需要加，在存在改动的地方加</strong></p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#007f7f">// CacheItem is an individual cache item
</span><span style="color:#007f7f">// Parameter data contains the user-set value in the cache. key对应的value
</span><span style="color:#007f7f"></span><span style="color:#fff;font-weight:bold">type</span> CacheItem <span style="color:#fff;font-weight:bold">struct</span> {
	sync.RWMutex

	<span style="color:#007f7f">// The item&#39;s key.
</span><span style="color:#007f7f"></span>	key <span style="color:#fff;font-weight:bold">interface</span>{}
	<span style="color:#007f7f">// The item&#39;s data.
</span><span style="color:#007f7f"></span>	data <span style="color:#fff;font-weight:bold">interface</span>{}
	<span style="color:#007f7f">// How long will the item live in the cache when not being accessed/kept alive.
</span><span style="color:#007f7f"></span>	lifeSpan time.Duration

	<span style="color:#007f7f">// Creation timestamp.
</span><span style="color:#007f7f"></span>	createdOn time.Time
	<span style="color:#007f7f">// Last access timestamp.
</span><span style="color:#007f7f"></span>	accessedOn time.Time
	<span style="color:#007f7f">// How often the item was accessed.
</span><span style="color:#007f7f"></span>	accessCount <span style="color:#fff;font-weight:bold">int64</span>

	<span style="color:#007f7f">// Callback method triggered right before removing the item from the cache
</span><span style="color:#007f7f"></span>    <span style="color:#007f7f">// 在删除缓存项之前调用的回调函数
</span><span style="color:#007f7f"></span>	aboutToExpire <span style="color:#fff;font-weight:bold">func</span>(key <span style="color:#fff;font-weight:bold">interface</span>{})
}

<span style="color:#007f7f">// NewCacheItem returns a newly created CacheItem.
</span><span style="color:#007f7f">// Parameter key is the item&#39;s cache-key.
</span><span style="color:#007f7f">// Parameter lifeSpan determines after which time period without an access the item
</span><span style="color:#007f7f">// will get removed from the cache.
</span><span style="color:#007f7f">// Parameter data is the item&#39;s value.
</span><span style="color:#007f7f">// 构造一个新的缓存项实体，相当于构造函数
</span><span style="color:#007f7f">// 时间用的是当前时间time.Now()
</span><span style="color:#007f7f"></span><span style="color:#fff;font-weight:bold">func</span> NewCacheItem(key <span style="color:#fff;font-weight:bold">interface</span>{}, lifeSpan time.Duration, data <span style="color:#fff;font-weight:bold">interface</span>{}) *CacheItem {
	t := time.Now()
	<span style="color:#fff;font-weight:bold">return</span> &amp;CacheItem{
		key:           key,
		lifeSpan:      lifeSpan,
		createdOn:     t,
		accessedOn:    t,
		accessCount:   <span style="color:#ff0;font-weight:bold">0</span>,
		aboutToExpire: <span style="color:#fff;font-weight:bold">nil</span>,
		data:          data,
	}
}

<span style="color:#007f7f">// KeepAlive marks an item to be kept for another expireDuration period.
</span><span style="color:#007f7f"></span><span style="color:#fff;font-weight:bold">func</span> (item *CacheItem) KeepAlive() {
	item.Lock()
	<span style="color:#fff;font-weight:bold">defer</span> item.Unlock()
	item.accessedOn = time.Now()<span style="color:#007f7f">// 很机智，改变过期时间的方法居然是吧开始时间改成当前的
</span><span style="color:#007f7f"></span>	item.accessCount++
}

<span style="color:#007f7f">// LifeSpan returns this item&#39;s expiration duration.
</span><span style="color:#007f7f"></span><span style="color:#fff;font-weight:bold">func</span> (item *CacheItem) LifeSpan() time.Duration {
	<span style="color:#007f7f">// immutable
</span><span style="color:#007f7f"></span>	<span style="color:#fff;font-weight:bold">return</span> item.lifeSpan
}

<span style="color:#007f7f">// AccessedOn returns when this item was last accessed.
</span><span style="color:#007f7f"></span><span style="color:#fff;font-weight:bold">func</span> (item *CacheItem) AccessedOn() time.Time {
	item.RLock()
	<span style="color:#fff;font-weight:bold">defer</span> item.RUnlock()
	<span style="color:#fff;font-weight:bold">return</span> item.accessedOn
}

<span style="color:#007f7f">// CreatedOn returns when this item was added to the cache.
</span><span style="color:#007f7f"></span><span style="color:#fff;font-weight:bold">func</span> (item *CacheItem) CreatedOn() time.Time {
	<span style="color:#007f7f">// immutable
</span><span style="color:#007f7f"></span>	<span style="color:#fff;font-weight:bold">return</span> item.createdOn
}

<span style="color:#007f7f">// AccessCount returns how often this item has been accessed.
</span><span style="color:#007f7f"></span><span style="color:#fff;font-weight:bold">func</span> (item *CacheItem) AccessCount() <span style="color:#fff;font-weight:bold">int64</span> {
	item.RLock()
	<span style="color:#fff;font-weight:bold">defer</span> item.RUnlock()
	<span style="color:#fff;font-weight:bold">return</span> item.accessCount
}

<span style="color:#007f7f">// Key returns the key of this cached item.
</span><span style="color:#007f7f"></span><span style="color:#fff;font-weight:bold">func</span> (item *CacheItem) Key() <span style="color:#fff;font-weight:bold">interface</span>{} {
	<span style="color:#007f7f">// immutable
</span><span style="color:#007f7f"></span>	<span style="color:#fff;font-weight:bold">return</span> item.key
}

<span style="color:#007f7f">// Data returns the value of this cached item.
</span><span style="color:#007f7f"></span><span style="color:#fff;font-weight:bold">func</span> (item *CacheItem) Data() <span style="color:#fff;font-weight:bold">interface</span>{} {
	<span style="color:#007f7f">// immutable
</span><span style="color:#007f7f"></span>	<span style="color:#fff;font-weight:bold">return</span> item.data
}

<span style="color:#007f7f">// SetAboutToExpireCallback configures a callback, which will be called right
</span><span style="color:#007f7f">// before the item is about to be removed from the cache.
</span><span style="color:#007f7f"></span><span style="color:#fff;font-weight:bold">func</span> (item *CacheItem) SetAboutToExpireCallback(f <span style="color:#fff;font-weight:bold">func</span>(<span style="color:#fff;font-weight:bold">interface</span>{})) {
	item.Lock()
	<span style="color:#fff;font-weight:bold">defer</span> item.Unlock()
	item.aboutToExpire = f
}
</code></pre></div><h4 id="errors">Errors</h4>
<p>另外作者为了方便，还自己封装了常用的Error，学习到了</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#fff;font-weight:bold">var</span> (
	<span style="color:#007f7f">// ErrKeyNotFound gets returned when a specific key couldn&#39;t be found
</span><span style="color:#007f7f"></span>	ErrKeyNotFound = errors.New(<span style="color:#0ff;font-weight:bold">&#34;Key not found in cache&#34;</span>)
	<span style="color:#007f7f">// ErrKeyNotFoundOrLoadable gets returned when a specific key couldn&#39;t be
</span><span style="color:#007f7f"></span>	<span style="color:#007f7f">// found and loading via the data-loader callback also failed
</span><span style="color:#007f7f"></span>	ErrKeyNotFoundOrLoadable = errors.New(<span style="color:#0ff;font-weight:bold">&#34;Key not found and could not be loaded into cache&#34;</span>)
)
</code></pre></div>
      </div>


      <footer>
        


        <div id="disqus_thread"></div>
<script type="application/javascript">
    var disqus_config = function () {
    
    
    
    };
    (function() {
        if (["localhost", "127.0.0.1"].indexOf(window.location.hostname) != -1) {
            document.getElementById('disqus_thread').innerHTML = 'Disqus comments not available by default when the website is previewed locally.';
            return;
        }
        var d = document, s = d.createElement('script'); s.async = true;
        s.src = '//' + "yourdiscussshortname" + '.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="https://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
        
        
      </footer>
    </article>

    
  </section>

      </div>

      
  <footer class="footer">
    <section class="container">
      
        <p>Enter a text here.</p>
      
      
        ©
        
          2019 -
        
        2020
         Toby 
      
      
         · 
        Powered by <a href="https://gohugo.io/">Hugo</a> & <a href="https://github.com/luizdepra/hugo-coder/">Coder</a>.
      
      
    </section>
  </footer>


    </main>

    
      
        
        <script src="/hugo/js/dark-mode.min.0213e1773e6d1c5a644f847c67a6f8abac49a3776e2976f6008038af8c5b76a1.js"></script>
      
    

    

    

    

    

    
  </body>

</html>
